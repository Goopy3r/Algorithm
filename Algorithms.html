<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Maze Generation and Solving Animation</title>
    <style>
        :root {
            --primary-dark: #0A0A15;
            --accent-purple: #3A1C71;
            --accent-blue: #1E90FF;
            --accent-green: #00FF7F;
            --accent-red: #FF3333;
            --accent-orange: #FF9500;
            --accent-pink: #FF00FF;
        }
        
        body {
            margin: 0;
            padding: 0;
            background-color: var(--primary-dark);
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        canvas {
            display: block;
        }
        
        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            z-index: 10;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            width: 280px;
        }
        
        .stats {
            margin-bottom: 15px;
            font-size: 14px;
            line-height: 1.5;
        }
        
        .stat-value {
            color: var(--accent-green);
            font-weight: bold;
        }
        
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 10px;
        }
        
        button {
            background-color: var(--accent-purple);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            flex: 1;
            min-width: 80px;
        }
        
        button:hover {
            background-color: #4A2C81;
            transform: translateY(-2px);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button.toggled {
            background-color: var(--accent-blue);
            box-shadow: 0 0 8px rgba(30, 144, 255, 0.6);
        }
        
        .slider-container {
            margin: 10px 0;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }
        
        input[type="range"] {
            width: 100%;
            height: 5px;
            border-radius: 5px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent-blue);
            cursor: pointer;
        }
        
        .size-value {
            display: inline-block;
            width: 30px;
            text-align: center;
            font-weight: bold;
        }
        
        .algorithm-info {
            margin-top: 10px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            font-size: 12px;
        }
        
        .performance-warning {
            color: var(--accent-red);
            font-size: 11px;
            margin-top: 5px;
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="mazeCanvas"></canvas>
    <div class="controls">
        <div class="stats" id="stats">
            <div id="status">Initializing...</div>
            <div>Cells: <span id="cellCount" class="stat-value">0</span></div>
            <div>Path length: <span id="pathLength" class="stat-value">0</span></div>
            <div>FPS: <span id="fpsCounter" class="stat-value">0</span></div>
        </div>
        
        <div class="button-group">
            <button id="restartBtn">Restart</button>
            <button id="pauseBtn">Pause</button>
            <button id="stepBtn">Step</button>
        </div>
        
        <div class="slider-container">
            <label for="mazeSizeSlider">Maze Size: <span id="sizeValue" class="size-value">30</span></label>
            <input type="range" id="mazeSizeSlider" min="10" max="80" value="30">
            <div id="performanceWarning" class="performance-warning">Large sizes may affect performance</div>
        </div>
        
        <div class="button-group">
            <button id="primBtn" class="toggled">Prim's</button>
            <button id="huntkillBtn">Hunt & Kill</button>
            <button id="aldousbroderBtn">Aldous-Broder</button>
        </div>
        
        <div class="button-group">
            <button id="astarBtn" class="toggled">A*</button>
            <button id="dijkstraBtn">Dijkstra</button>
            <button id="bfsBtn">BFS</button>
        </div>
        
        <div class="algorithm-info" id="algorithmInfo">
            Prim's Algorithm: Creates a maze by randomly growing from a starting point, resulting in many short dead ends.
        </div>
    </div>

    <script>
        // Configuration constants
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 800;
        let MAZE_SIZE = 30; // Default size, will be updated by slider

        // Color definitions
        const BG_COLOR = '#0A0A15';
        const WALL_COLOR = '#FFFFFF';
        const CURRENT_COLOR = '#FF1493';
        const GENERATION_PARTICLE = '#00FF7F';
        const SOLVING_PARTICLE = '#1E90FF';
        const VISITED_COLOR = '#3A1C71';
        const PATH_COLOR = '#FF3333';
        const START_COLOR = '#00FF7F';
        const END_COLOR = '#FF4500';
        const PRIM_GENERATION_PARTICLE = '#FF9500';
        const ASTAR_SOLVING_PARTICLE = '#FF00FF';

        // Animation settings
        const PARTICLE_LIFETIME = 3;
        const PARTICLE_SIZE = 0.8;
        const GEN_DURATION = 3;
        const SOLVE_DURATION = 4;
        const TARGET_FPS = 60; // Increased from 30 to 60 for smoother animation
        let GEN_FRAMES = GEN_DURATION * TARGET_FPS;
        let SOLVE_FRAMES = SOLVE_DURATION * TARGET_FPS;
        let TOTAL_FRAMES = GEN_FRAMES + SOLVE_FRAMES;
        const GLOW_INTENSITY = 1.2;
        const PULSE_SPEED = 0.15;

        // Global variables
        let canvas, ctx;
        let grid = [];
        let generationStates = [];
        let solvingStates = [];
        let frames = [];
        let particles = [];
        let currentFrame = 0;
        let animationId = null;
        let isPaused = false;
        let totalCells = 0;
        let entrancePos, exitPos;
        let cellSize;
        let xOffset, yOffset;
        let lastFrameTime = 0;
        let fps = 0;
        let pathLength = 0;
        
        // Algorithm selection
        let generationAlgorithm = 'prim';
        let solvingAlgorithm = 'astar';
        
        // Performance optimization
        let precomputedGradientColors = {};
        let offscreenCanvas = document.createElement('canvas');
        let offscreenCtx = offscreenCanvas.getContext('2d');

        class Particle {
            constructor(x, y, color, size = PARTICLE_SIZE, lifetime = PARTICLE_LIFETIME, velocity = [0, 0]) {
                this.x = x;
                this.y = y;
                this.originalColor = color;
                this.color = color;
                this.size = size * (0.8 + Math.random() * 0.4);
                this.maxLifetime = lifetime;
                this.lifetime = lifetime;
                this.decay = 0.85;
                this.vx = velocity[0] * (0.5 + Math.random());
                this.vy = velocity[1] * (0.5 + Math.random());
            }

            update() {
                this.lifetime--;
                this.size *= this.decay;
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.9;
                this.vy *= 0.9;

                const alpha = this.lifetime / this.maxLifetime;
                const [r, g, b] = this.originalColor;
                this.color = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                return this.lifetime > 0 && this.size > 0.1;
            }
        }

        class Cell {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.walls = { N: true, E: true, S: true, W: true };
                this.visited = false;
                this.inPath = false;
                this.isStart = false;
                this.isEnd = false;
                this.isFrontier = false;
                this.generationOrder = -1;
                this.distance = Infinity;
                this.inCurrentPath = false;
            }
        }

        // Improved maze generation algorithms

        function createMazePrim(width, height) {
            grid = Array.from({ length: width }, (_, x) => 
                Array.from({ length: height }, (_, y) => new Cell(x, y))
            );
            
            generationStates = [];
            let cellsAdded = 0;

            // Start with a random cell
            const startX = Math.floor(Math.random() * width);
            const startY = Math.floor(Math.random() * height);
            grid[startX][startY].visited = true;
            grid[startX][startY].generationOrder = cellsAdded;
            cellsAdded++;

            // Add the initial cell to the maze
            generationStates.push(captureGenerationState(grid, grid[startX][startY], [], [], [[startX, startY]]));

            // Create a list of frontier cells (neighbors of visited cells)
            const frontier = [];
            const directions = [['N', 0, -1], ['E', 1, 0], ['S', 0, 1], ['W', -1, 0]];
            const opposite = { N: 'S', E: 'W', S: 'N', W: 'E' };

            // Add the initial frontier cells
            for (const [direction, dx, dy] of directions) {
                const nx = startX + dx;
                const ny = startY + dy;
                if (nx >= 0 && nx < width && ny >= 0 && ny < height && !grid[nx][ny].visited) {
                    frontier.push([nx, ny, startX, startY, direction]);
                    grid[nx][ny].isFrontier = true;
                }
            }

            // Capture state with frontier
            generationStates.push(captureGenerationState(
                grid, 
                grid[startX][startY], 
                [], 
                [], 
                frontier.map(([nx, ny]) => [nx, ny])
            ));

            while (frontier.length > 0) {
                // Randomly select a frontier cell
                const idx = Math.floor(Math.random() * frontier.length);
                const [fx, fy, px, py, dirFromParent] = frontier.splice(idx, 1)[0];
                
                // Mark the frontier cell as visited and remove it from frontier
                grid[fx][fy].visited = true;
                grid[fx][fy].generationOrder = cellsAdded;
                cellsAdded++;
                grid[fx][fy].isFrontier = false;
                
                // Remove the wall between the frontier cell and its parent
                grid[px][py].walls[dirFromParent] = false;
                grid[fx][fy].walls[opposite[dirFromParent]] = false;
                
                // Capture state after connecting the cell
                generationStates.push(captureGenerationState(
                    grid, 
                    grid[fx][fy], 
                    [], 
                    [], 
                    [[fx, fy]], 
                    frontier.map(([nx, ny]) => [nx, ny])
                ));
                
                // Add new frontier cells
                for (const [direction, dx, dy] of directions) {
                    const nx = fx + dx;
                    const ny = fy + dy;
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height && 
                        !grid[nx][ny].visited && !grid[nx][ny].isFrontier) {
                        frontier.push([nx, ny, fx, fy, direction]);
                        grid[nx][ny].isFrontier = true;
                    }
                }
                
                // Capture state with updated frontier
                generationStates.push(captureGenerationState(
                    grid, 
                    grid[fx][fy], 
                    [], 
                    [], 
                    [[fx, fy]], 
                    frontier.map(([nx, ny]) => [nx, ny])
                ));
            }

            // Create entrance and exit
            createEntranceAndExit(width, height);
            
            generationStates.push(captureGenerationState(grid, null, [], []));
            return { grid, generationStates, cellsAdded, entrancePos, exitPos };
        }

        // Hunt and Kill Algorithm
        function createMazeHuntAndKill(width, height) {
            grid = Array.from({ length: width }, (_, x) => 
                Array.from({ length: height }, (_, y) => new Cell(x, y))
            );
            
            generationStates = [];
            let cellsAdded = 0;
            
            // Start with a random cell
            let currentX = Math.floor(Math.random() * width);
            let currentY = Math.floor(Math.random() * height);
            grid[currentX][currentY].visited = true;
            grid[currentX][currentY].generationOrder = cellsAdded++;
            
            generationStates.push(captureGenerationState(grid, grid[currentX][currentY], [], []));
            
            const directions = [['N', 0, -1], ['E', 1, 0], ['S', 0, 1], ['W', -1, 0]];
            const opposite = { N: 'S', E: 'W', S: 'N', W: 'E' };
            
            while (true) {
                // Get unvisited neighbors
                const unvisitedNeighbors = [];
                for (const [direction, dx, dy] of directions) {
                    const nx = currentX + dx;
                    const ny = currentY + dy;
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height && !grid[nx][ny].visited) {
                        unvisitedNeighbors.push([nx, ny, direction]);
                    }
                }
                
                if (unvisitedNeighbors.length > 0) {
                    // Randomly choose an unvisited neighbor
                    const [nx, ny, direction] = unvisitedNeighbors[Math.floor(Math.random() * unvisitedNeighbors.length)];
                    
                    // Remove the wall between current cell and chosen neighbor
                    grid[currentX][currentY].walls[direction] = false;
                    grid[nx][ny].walls[opposite[direction]] = false;
                    
                    // Move to the neighbor
                    currentX = nx;
                    currentY = ny;
                    grid[currentX][currentY].visited = true;
                    grid[currentX][currentY].generationOrder = cellsAdded++;
                    
                    generationStates.push(captureGenerationState(grid, grid[currentX][currentY], [], []));
                } else {
                    // Hunt for a new unvisited cell with visited neighbors
                    let found = false;
                    for (let x = 0; x < width && !found; x++) {
                        for (let y = 0; y < height && !found; y++) {
                            if (!grid[x][y].visited) {
                                // Check if this unvisited cell has visited neighbors
                                const visitedNeighbors = [];
                                for (const [direction, dx, dy] of directions) {
                                    const nx = x + dx;
                                    const ny = y + dy;
                                    if (nx >= 0 && nx < width && ny >= 0 && ny < height && grid[nx][ny].visited) {
                                        visitedNeighbors.push([nx, ny, direction]);
                                    }
                                }
                                
                                if (visitedNeighbors.length > 0) {
                                    // Connect to a random visited neighbor
                                    const [nx, ny, direction] = visitedNeighbors[Math.floor(Math.random() * visitedNeighbors.length)];
                                    
                                    // Remove the wall between the cells
                                    grid[x][y].walls[direction] = false;
                                    grid[nx][ny].walls[opposite[direction]] = false;
                                    
                                    // Set as current cell
                                    currentX = x;
                                    currentY = y;
                                    grid[currentX][currentY].visited = true;
                                    grid[currentX][currentY].generationOrder = cellsAdded++;
                                    
                                    generationStates.push(captureGenerationState(grid, grid[currentX][currentY], [], []));
                                    found = true;
                                }
                            }
                        }
                    }
                    
                    // If no unvisited cell with visited neighbors found, we're done
                    if (!found) break;
                }
            }
            
            // Create entrance and exit
            createEntranceAndExit(width, height);
            
            generationStates.push(captureGenerationState(grid, null, [], []));
            return { grid, generationStates, cellsAdded, entrancePos, exitPos };
        }

        // Aldous-Broder Algorithm
        function createMazeAldousBroder(width, height) {
            grid = Array.from({ length: width }, (_, x) => 
                Array.from({ length: height }, (_, y) => new Cell(x, y))
            );
            
            generationStates = [];
            let cellsAdded = 0;
            
            // Start with a random cell
            let currentX = Math.floor(Math.random() * width);
            let currentY = Math.floor(Math.random() * height);
            grid[currentX][currentY].visited = true;
            grid[currentX][currentY].generationOrder = cellsAdded++;
            
            generationStates.push(captureGenerationState(grid, grid[currentX][currentY], [], []));
            
            const directions = [['N', 0, -1], ['E', 1, 0], ['S', 0, 1], ['W', -1, 0]];
            const opposite = { N: 'S', E: 'W', S: 'N', W: 'E' };
            
            let unvisitedCount = width * height - 1;
            
            while (unvisitedCount > 0) {
                // Get all neighbors
                const neighbors = [];
                for (const [direction, dx, dy] of directions) {
                    const nx = currentX + dx;
                    const ny = currentY + dy;
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                        neighbors.push([nx, ny, direction]);
                    }
                }
                
                // Randomly choose a neighbor
                const [nx, ny, direction] = neighbors[Math.floor(Math.random() * neighbors.length)];
                
                if (!grid[nx][ny].visited) {
                    // Remove the wall between current cell and chosen neighbor
                    grid[currentX][currentY].walls[direction] = false;
                    grid[nx][ny].walls[opposite[direction]] = false;
                    
                    // Mark the neighbor as visited
                    grid[nx][ny].visited = true;
                    grid[nx][ny].generationOrder = cellsAdded++;
                    unvisitedCount--;
                }
                
                // Move to the neighbor
                currentX = nx;
                currentY = ny;
                
                generationStates.push(captureGenerationState(grid, grid[currentX][currentY], [], []));
            }
            
            // Create entrance and exit
            createEntranceAndExit(width, height);
            
            generationStates.push(captureGenerationState(grid, null, [], []));
            return { grid, generationStates, cellsAdded, entrancePos, exitPos };
        }

        function createEntranceAndExit(width, height) {
            const entranceX = Math.floor(Math.random() * (width - 2)) + 1;
            const exitX = Math.floor(Math.random() * (width - 2)) + 1;
            grid[entranceX][0].walls.N = false;
            grid[exitX][height - 1].walls.S = false;
            grid[entranceX][0].visited = true;
            grid[exitX][height - 1].visited = true;
            grid[entranceX][0].isStart = true;
            grid[exitX][height - 1].isEnd = true;
            entrancePos = [entranceX, 0];
            exitPos = [exitX, height - 1];

            // Ensure outer walls are intact except for entrance and exit
            for (let x = 0; x < width; x++) {
                for (let y = 0; y < height; y++) {
                    if (y === 0 && x !== entranceX) grid[x][y].walls.N = true;
                    if (y === height - 1 && x !== exitX) grid[x][y].walls.S = true;
                    if (x === 0) grid[x][y].walls.W = true;
                    if (x === width - 1) grid[x][y].walls.E = true;
                }
            }
        }

        function captureGenerationState(grid, currentCell, path, walls, activeCells = [], frontierCells = [], isWilsonWalk = false) {
            // Performance optimization: Only capture necessary data
            const wallsData = grid.map(row => row.map(cell => ({ ...cell.walls })));
            const visitedData = grid.map(row => row.map(cell => cell.visited));
            const inPathData = grid.map(row => row.map(cell => cell.inPath));
            const isStartData = grid.map(row => row.map(cell => cell.isStart));
            const isEndData = grid.map(row => row.map(cell => cell.isEnd));
            const isFrontierData = grid.map(row => row.map(cell => cell.isFrontier));
            const generationOrderData = grid.map(row => row.map(cell => cell.generationOrder));
            const inCurrentPathData = grid.map(row => row.map(cell => cell.inCurrentPath));

            return {
                walls: wallsData,
                visited: visitedData,
                inPath: inPathData,
                isStart: isStartData,
                isEnd: isEndData,
                isFrontier: isFrontierData,
                generationOrder: generationOrderData,
                inCurrentPath: inCurrentPathData,
                current: currentCell ? [currentCell.x, currentCell.y] : null,
                path: path.map(cell => [cell.x, cell.y]),
                wallsToCheck: walls,
                phase: 'generation',
                activeCells: activeCells,
                frontierCells: frontierCells,
                isWilsonWalk: isWilsonWalk
            };
        }

        function heuristic(a, b) {
            // Manhattan distance
            return Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1]);
        }

        function solveMazeAStar(grid, startPos, endPos) {
            const width = grid.length;
            const height = grid[0].length;
            const [startX, startY] = startPos;
            const [endX, endY] = endPos;

            // Reset grid for solving
            for (let x = 0; x < width; x++) {
                for (let y = 0; y < height; y++) {
                    grid[x][y].visited = false;
                    grid[x][y].inPath = false;
                    grid[x][y].distance = Infinity;
                }
            }

            grid[startX][startY].isStart = true;
            grid[endX][endY].isEnd = true;
            grid[startX][startY].distance = 0;

            // Priority queue: [fScore, gScore, x, y]
            const priorityQueue = new FastPriorityQueue((a, b) => a[0] < b[0]);
            priorityQueue.add([heuristic(startPos, endPos), 0, startX, startY]);
            
            const visited = new Set();
            const cameFrom = {};
            solvingStates = [];
            const explorationPath = [grid[startX][startY]];

            const activeCells = [[startX, startY]];
            solvingStates.push(captureSolvingState(grid, grid[startX][startY], explorationPath, [], false, activeCells));

            let solutionFound = false;
            let finalPath = [];

            const directions = [['N', 0, -1], ['E', 1, 0], ['S', 0, 1], ['W', -1, 0]];

            // Initialize gScore and fScore arrays
            const gScore = Array.from({ length: width }, () => Array(height).fill(Infinity));
            gScore[startX][startY] = 0;

            const fScore = Array.from({ length: width }, () => Array(height).fill(Infinity));
            fScore[startX][startY] = heuristic(startPos, endPos);

            while (!priorityQueue.isEmpty() && !solutionFound) {
                // Get the node with the lowest fScore
                const [currentF, currentG, x, y] = priorityQueue.poll();
                const currentPos = [x, y];

                if (visited.has(currentPos.toString())) continue;

                visited.add(currentPos.toString());
                grid[x][y].visited = true;

                explorationPath.push(grid[x][y]);
                if (explorationPath.length > 6) {
                    explorationPath.shift();
                }

                if (x === endX && y === endY) {
                    solutionFound = true;
                    let tempPos = currentPos;
                    while (cameFrom[tempPos]) {
                        finalPath.push(tempPos);
                        tempPos = cameFrom[tempPos];
                    }
                    finalPath.push(startPos);
                    finalPath.reverse();
                    pathLength = finalPath.length;

                    activeCells.push([endX, endY]);
                    solvingStates.push(captureSolvingState(grid, grid[endX][endY], explorationPath, [], false, activeCells));
                    continue;
                }

                const frontierPositions = [];
                activeCells.push([x, y]);

                for (const [direction, dx, dy] of directions) {
                    const nx = x + dx;
                    const ny = y + dy;

                    if (nx >= 0 && nx < width && ny >= 0 && ny < height && !visited.has([nx, ny].toString())) {
                        let canMove = false;
                        if (direction === 'N' && !grid[x][y].walls.N) canMove = true;
                        if (direction === 'S' && !grid[x][y].walls.S) canMove = true;
                        if (direction === 'E' && !grid[x][y].walls.E) canMove = true;
                        if (direction === 'W' && !grid[x][y].walls.W) canMove = true;

                        if (canMove) {
                            const tentativeGScore = gScore[x][y] + 1;

                            if (tentativeGScore < gScore[nx][ny]) {
                                cameFrom[[nx, ny]] = [x, y];
                                gScore[nx][ny] = tentativeGScore;
                                fScore[nx][ny] = tentativeGScore + heuristic([nx, ny], endPos);
                                
                                priorityQueue.add([fScore[nx][ny], tentativeGScore, nx, ny]);
                                frontierPositions.push([nx, ny]);
                            }
                            activeCells.push([nx, ny]);
                        }
                    }
                }

                if (!solutionFound) {
                    if (solvingStates.length % 8 === 0) {
                        solvingStates.push(captureSolvingState(
                            grid, 
                            grid[x][y], 
                            explorationPath, 
                            frontierPositions, 
                            false, 
                            activeCells, 
                            gScore
                        ));
                    }
                }
            }

            if (solutionFound) {
                // Capture path progression
                const step = Math.max(1, Math.floor(finalPath.length / 8));
                for (let i = 0; i <= finalPath.length; i += step) {
                    const partialPath = [];
                    for (let j = 0; j < Math.min(i, finalPath.length); j++) {
                        const [px, py] = finalPath[j];
                        partialPath.push(grid[px][py]);
                    }
                    solvingStates.push(captureSolvingState(grid, grid[endX][endY], partialPath, [], true));
                }

                for (const [px, py] of finalPath) {
                    grid[px][py].inPath = true;
                }

                const finalPathCells = finalPath.map(([px, py]) => grid[px][py]);
                for (let i = 0; i < 2; i++) {
                    solvingStates.push(captureSolvingState(grid, grid[endX][endY], finalPathCells, [], true));
                }
            }

            return solvingStates;
        }

        function solveMazeBFS(grid, startPos, endPos) {
            const width = grid.length;
            const height = grid[0].length;
            const [startX, startY] = startPos;
            const [endX, endY] = endPos;

            // Reset grid for solving
            for (let x = 0; x < width; x++) {
                for (let y = 0; y < height; y++) {
                    grid[x][y].visited = false;
                    grid[x][y].inPath = false;
                    grid[x][y].distance = Infinity;
                }
            }

            grid[startX][startY].isStart = true;
            grid[endX][endY].isEnd = true;
            grid[startX][startY].distance = 0;

            const queue = [[startX, startY]];
            const visited = new Set();
            visited.add([startX, startY].toString());
            const cameFrom = {};
            solvingStates = [];
            const explorationPath = [grid[startX][startY]];

            const activeCells = [[startX, startY]];
            solvingStates.push(captureSolvingState(grid, grid[startX][startY], explorationPath, [], false, activeCells));

            let solutionFound = false;
            let finalPath = [];

            const directions = [['N', 0, -1], ['E', 1, 0], ['S', 0, 1], ['W', -1, 0]];

            while (queue.length > 0 && !solutionFound) {
                const [x, y] = queue.shift();
                grid[x][y].visited = true;

                explorationPath.push(grid[x][y]);
                if (explorationPath.length > 6) {
                    explorationPath.shift();
                }

                if (x === endX && y === endY) {
                    solutionFound = true;
                    let tempPos = [x, y];
                    while (cameFrom[tempPos]) {
                        finalPath.push(tempPos);
                        tempPos = cameFrom[tempPos];
                    }
                    finalPath.push(startPos);
                    finalPath.reverse();
                    pathLength = finalPath.length;

                    activeCells.push([endX, endY]);
                    solvingStates.push(captureSolvingState(grid, grid[endX][endY], explorationPath, [], false, activeCells));
                    continue;
                }

                const frontierPositions = [];
                activeCells.push([x, y]);

                for (const [direction, dx, dy] of directions) {
                    const nx = x + dx;
                    const ny = y + dy;

                    if (nx >= 0 && nx < width && ny >= 0 && ny < height && !visited.has([nx, ny].toString())) {
                        let canMove = false;
                        if (direction === 'N' && !grid[x][y].walls.N) canMove = true;
                        if (direction === 'S' && !grid[x][y].walls.S) canMove = true;
                        if (direction === 'E' && !grid[x][y].walls.E) canMove = true;
                        if (direction === 'W' && !grid[x][y].walls.W) canMove = true;

                        if (canMove) {
                            visited.add([nx, ny].toString());
                            queue.push([nx, ny]);
                            cameFrom[[nx, ny]] = [x, y];
                            frontierPositions.push([nx, ny]);
                            activeCells.push([nx, ny]);
                        }
                    }
                }

                if (!solutionFound) {
                    if (solvingStates.length % 8 === 0) {
                        solvingStates.push(captureSolvingState(
                            grid, 
                            grid[x][y], 
                            explorationPath, 
                            frontierPositions, 
                            false, 
                            activeCells
                        ));
                    }
                }
            }

            if (solutionFound) {
                // Capture path progression
                const step = Math.max(1, Math.floor(finalPath.length / 8));
                for (let i = 0; i <= finalPath.length; i += step) {
                    const partialPath = [];
                    for (let j = 0; j < Math.min(i, finalPath.length); j++) {
                        const [px, py] = finalPath[j];
                        partialPath.push(grid[px][py]);
                    }
                    solvingStates.push(captureSolvingState(grid, grid[endX][endY], partialPath, [], true));
                }

                for (const [px, py] of finalPath) {
                    grid[px][py].inPath = true;
                }

                const finalPathCells = finalPath.map(([px, py]) => grid[px][py]);
                for (let i = 0; i < 2; i++) {
                    solvingStates.push(captureSolvingState(grid, grid[endX][endY], finalPathCells, [], true));
                }
            }

            return solvingStates;
        }

        function solveMazeDijkstra(grid, startPos, endPos) {
            // Dijkstra's algorithm is similar to A* but without the heuristic
            // We'll reuse A* but with heuristic always returning 0
            const originalHeuristic = heuristic;
            heuristic = () => 0;
            const result = solveMazeAStar(grid, startPos, endPos);
            heuristic = originalHeuristic;
            return result;
        }

        function captureSolvingState(grid, currentCell, path, frontierPositions, isSolutionPhase = false, activeCells = null, distanceGrid = null) {
            // Performance optimization: Only capture necessary data
            const wallsData = grid.map(row => row.map(cell => ({ ...cell.walls })));
            const visitedData = grid.map(row => row.map(cell => cell.visited));
            const inPathData = grid.map(row => row.map(cell => cell.inPath || path.includes(cell)));
            const isStartData = grid.map(row => row.map(cell => cell.isStart));
            const isEndData = grid.map(row => row.map(cell => cell.isEnd));
            const generationOrderData = grid.map(row => row.map(cell => cell.generationOrder));

            return {
                walls: wallsData,
                visited: visitedData,
                inPath: inPathData,
                isStart: isStartData,
                isEnd: isEndData,
                generationOrder: generationOrderData,
                current: currentCell ? [currentCell.x, currentCell.y] : null,
                path: path.map(cell => [cell.x, cell.y]),
                frontierPositions: frontierPositions,
                phase: 'solving',
                isSolutionPhase: isSolutionPhase,
                activeCells: activeCells || []
            };
        }

        function createAnimationFrames(generationStates, solvingStates) {
            const frames = [];
            
            // Sample generation states with adaptive sampling
            const genTotalStates = generationStates.length;
            const genStep = Math.max(1, Math.floor(genTotalStates / GEN_FRAMES));
            for (let frameIdx = 0; frameIdx < genTotalStates; frameIdx += genStep) {
                frames.push(generationStates[frameIdx]);
            }
            
            // Fill any remaining frames with the last state
            while (frames.length < GEN_FRAMES) {
                frames.push(generationStates[generationStates.length - 1]);
            }
            
            // Sample solving states with adaptive sampling
            const solveTotalStates = solvingStates.length;
            const solveStep = Math.max(1, Math.floor(solveTotalStates / SOLVE_FRAMES));
            for (let frameIdx = 0; frameIdx < solveTotalStates; frameIdx += solveStep) {
                frames.push(solvingStates[frameIdx]);
            }
            
            // Fill any remaining frames with the last state
            while (frames.length < GEN_FRAMES + SOLVE_FRAMES) {
                frames.push(solvingStates[solvingStates.length - 1]);
            }
            
            return frames;
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? [
                parseInt(result[1], 16),
                parseInt(result[2], 16),
                parseInt(result[3], 16)
            ] : [0, 0, 0];
        }

        function hsvToRgb(h, s, v) {
            let r, g, b;
            const i = Math.floor(h * 6);
            const f = h * 6 - i;
            const p = v * (1 - s);
            const q = v * (1 - f * s);
            const t = v * (1 - (1 - f) * s);
            
            switch (i % 6) {
                case 0: r = v; g = t; b = p; break;
                case 1: r = q; g = v; b = p; break;
                case 2: r = p; g = v; b = t; break;
                case 3: r = p; g = q; b = v; break;
                case 4: r = t; g = p; b = v; break;
                case 5: r = v; g = p; b = q; break;
            }
            
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        function createGradientColor(order, total) {
            if (order < 0) return [25, 25, 51];
            
            // Cache colors for performance
            const cacheKey = `${order}-${total}`;
            if (precomputedGradientColors[cacheKey]) {
                return precomputedGradientColors[cacheKey];
            }
            
            const normPos = Math.min(1.0, order / total);
            const h1 = 0.11, s1 = 0.9, v1 = 0.8;
            const h2 = 0.65, s2 = 0.85, v2 = 0.9;
            const h = h1 + (h2 - h1) * normPos;
            const s = s1 + (s2 - s1) * normPos;
            const v = v1 + (v2 - v1) * normPos;
            
            const result = hsvToRgb(h, s, v);
            precomputedGradientColors[cacheKey] = result;
            return result;
        }

        function getRandomDirection() {
            const angle = Math.random() * Math.PI * 2;
            return [Math.cos(angle) * 0.02, Math.sin(angle) * 0.02];
        }

        function drawAnimation(timestamp) {
            if (isPaused || currentFrame >= frames.length) return;
            
            // Calculate FPS
            if (lastFrameTime) {
                const delta = timestamp - lastFrameTime;
                fps = Math.round(1000 / delta);
                document.getElementById('fpsCounter').textContent = fps;
            }
            lastFrameTime = timestamp;
            
            const frame = frames[currentFrame];
            ctx.fillStyle = BG_COLOR;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // Calculate cell size and offsets
            cellSize = Math.min(CANVAS_HEIGHT / MAZE_SIZE, CANVAS_WIDTH / MAZE_SIZE) * 0.85;
            xOffset = (CANVAS_WIDTH - MAZE_SIZE * cellSize) / 2;
            yOffset = (CANVAS_HEIGHT - MAZE_SIZE * cellSize) / 2;
            
            const wallsData = frame.walls;
            const visitedData = frame.visited;
            const inPathData = frame.inPath;
            const isStartData = frame.isStart;
            const isEndData = frame.isEnd;
            const generationOrderData = frame.generationOrder;
            const currentPos = frame.current;
            const pathPositions = frame.path;
            const phase = frame.phase;
            
            const pulseFactor = 1.0 + 0.1 * Math.sin(currentFrame * PULSE_SPEED);
            const activeCells = frame.activeCells || [];
            
            // Update status text
            const statusEl = document.getElementById('status');
            const cellCountEl = document.getElementById('cellCount');
            const pathLengthEl = document.getElementById('pathLength');
            
            cellCountEl.textContent = totalCells;
            pathLengthEl.textContent = pathLength;
            
            if (phase === 'generation') {
                const progressPercent = Math.min(100, Math.floor((currentFrame / Math.max(1, GEN_FRAMES - 1)) * 100));
                statusEl.innerHTML = `Maze Generation<br>Algorithm: ${generationAlgorithm.toUpperCase()}<br>Progress: ${progressPercent}%`;
            } else {
                const isSolutionPhase = frame.isSolutionPhase || false;
                const titleText = isSolutionPhase ? "Solution Path" : "Exploring Maze";
                const progressPercent = Math.min(100, Math.floor(((currentFrame - GEN_FRAMES) / Math.max(1, SOLVE_FRAMES - 1)) * 100));
                statusEl.innerHTML = `${titleText}<br>Algorithm: ${solvingAlgorithm.toUpperCase()}<br>Progress: ${progressPercent}%`;
            }
            
            // Draw cells
            for (let x = 0; x < MAZE_SIZE; x++) {
                for (let y = 0; y < MAZE_SIZE; y++) {
                    const cellX = xOffset + x * cellSize;
                    const cellY = yOffset + (MAZE_SIZE - 1 - y) * cellSize;
                    
                    const isCurrent = currentPos && x === currentPos[0] && y === currentPos[1];
                    const inPath = inPathData[x][y];
                    const visited = visitedData[x][y];
                    const isStart = isStartData[x][y];
                    const isEnd = isEndData[x][y];
                    const generationOrder = generationOrderData[x][y];
                    
                    let glow = false;
                    let glowSizeFactor = 1.0;
                    let cellColor = 'white';
                    let alpha = 0.05;
                    
                    if (isStart) {
                        cellColor = START_COLOR;
                        alpha = 1.0;
                        glow = true;
                        glowSizeFactor = 1.2 * pulseFactor;
                    } else if (isEnd) {
                        cellColor = END_COLOR;
                        alpha = 1.0;
                        glow = true;
                        glowSizeFactor = 1.2 * pulseFactor;
                    } else if (isCurrent) {
                        cellColor = phase === 'generation' ? PRIM_GENERATION_PARTICLE : ASTAR_SOLVING_PARTICLE;
                        alpha = 0.9;
                        glow = true;
                        glowSizeFactor = 1.15 * pulseFactor;
                    } else if (inPath) {
                        cellColor = PATH_COLOR;
                        const isFinalSolutionFrame = phase !== 'generation' && currentFrame >= GEN_FRAMES + SOLVE_FRAMES - 30;
                        alpha = isFinalSolutionFrame ? 1.0 : 0.8;
                        glow = true;
                        glowSizeFactor = (isFinalSolutionFrame ? 1.1 : 1.05) * pulseFactor;
                    } else if (visited) {
                        alpha = 0.7;
                        if (phase === 'generation') {
                            const [r, g, b] = createGradientColor(generationOrder, totalCells);
                            cellColor = `rgb(${r}, ${g}, ${b})`;
                        } else {
                            cellColor = VISITED_COLOR;
                        }
                    }
                    
                    // Draw cell
                    ctx.fillStyle = cellColor;
                    ctx.globalAlpha = alpha;
                    ctx.fillRect(cellX, cellY, cellSize, cellSize);
                    ctx.globalAlpha = 1.0;
                    
                    // Draw glow
                    if (glow) {
                        const glowSize = cellSize * glowSizeFactor;
                        const glowOffset = (cellSize - glowSize) / 2;
                        ctx.strokeStyle = cellColor;
                        ctx.globalAlpha = 0.4;
                        ctx.lineWidth = 1.5;
                        ctx.strokeRect(cellX + glowOffset, cellY + glowOffset, glowSize, glowSize);
                        ctx.globalAlpha = 1.0;
                    }
                }
            }
            
            // Draw walls
            ctx.strokeStyle = WALL_COLOR;
            ctx.lineWidth = 1.0;
            ctx.globalAlpha = 0.7;
            
            for (let x = 0; x < MAZE_SIZE; x++) {
                for (let y = 0; y < MAZE_SIZE; y++) {
                    const cellX = xOffset + x * cellSize;
                    const cellY = yOffset + (MAZE_SIZE - 1 - y) * cellSize;
                    const walls = wallsData[x][y];
                    
                    if (walls.N) {
                        ctx.beginPath();
                        ctx.moveTo(cellX, cellY + cellSize);
                        ctx.lineTo(cellX + cellSize, cellY + cellSize);
                        ctx.stroke();
                    }
                    if (walls.E) {
                        ctx.beginPath();
                        ctx.moveTo(cellX + cellSize, cellY);
                        ctx.lineTo(cellX + cellSize, cellY + cellSize);
                        ctx.stroke();
                    }
                    if (walls.S) {
                        ctx.beginPath();
                        ctx.moveTo(cellX, cellY);
                        ctx.lineTo(cellX + cellSize, cellY);
                        ctx.stroke();
                    }
                    if (walls.W) {
                        ctx.beginPath();
                        ctx.moveTo(cellX, cellY);
                        ctx.lineTo(cellX, cellY + cellSize);
                        ctx.stroke();
                    }
                }
            }
            ctx.globalAlpha = 1.0;
            
            // Update and draw particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                if (particle.update()) {
                    ctx.fillStyle = particle.color;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size * cellSize * 0.07, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    particles.splice(i, 1);
                }
            }
            
            // Add new particles
            if (phase === 'generation' && activeCells.length > 0 && Math.random() < 0.15) {
                for (const [ax, ay] of activeCells) {
                    const cellCenterX = xOffset + ax * cellSize + cellSize / 2;
                    const cellCenterY = yOffset + (MAZE_SIZE - 1 - ay) * cellSize + cellSize / 2;
                    const particleColor = hexToRgb(PRIM_GENERATION_PARTICLE);
                    
                    for (let i = 0; i < 2; i++) {
                        const [velX, velY] = getRandomDirection();
                        particles.push(new Particle(
                            cellCenterX + (Math.random() - 0.5) * 0.6 * cellSize,
                            cellCenterY + (Math.random() - 0.5) * 0.6 * cellSize,
                            particleColor,
                            Math.random() * 0.7 + 1.0,
                            Math.floor(Math.random() * 3) + 3,
                            [velX, velY]
                        ));
                    }
                }
            } else if (phase !== 'generation' && activeCells.length > 0 && Math.random() < 0.15) {
                for (const [ax, ay] of activeCells) {
                    const cellCenterX = xOffset + ax * cellSize + cellSize / 2;
                    const cellCenterY = yOffset + (MAZE_SIZE - 1 - ay) * cellSize + cellSize / 2;
                    const particleColor = hexToRgb(ASTAR_SOLVING_PARTICLE);
                    
                    for (let i = 0; i < 2; i++) {
                        const [velX, velY] = getRandomDirection();
                        particles.push(new Particle(
                            cellCenterX + (Math.random() - 0.5) * 0.6 * cellSize,
                            cellCenterY + (Math.random() - 0.5) * 0.6 * cellSize,
                            particleColor,
                            Math.random() * 0.7 + 1.0,
                            Math.floor(Math.random() * 3) + 3,
                            [velX, velY]
                        ));
                    }
                }
            }
            
            currentFrame++;
            if (currentFrame < frames.length) {
                animationId = requestAnimationFrame(drawAnimation);
            } else {
                console.log("Animation complete!");
            }
        }

        // Utility functions
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Fast priority queue implementation
        class FastPriorityQueue {
            constructor(comparator = (a, b) => a < b) {
                this.heap = [];
                this.comparator = comparator;
            }
            
            add(value) {
                this.heap.push(value);
                this.bubbleUp(this.heap.length - 1);
            }
            
            poll() {
                const result = this.heap[0];
                const end = this.heap.pop();
                if (this.heap.length > 0) {
                    this.heap[0] = end;
                    this.sinkDown(0);
                }
                return result;
            }
            
            isEmpty() {
                return this.heap.length === 0;
            }
            
            bubbleUp(index) {
                const element = this.heap[index];
                while (index > 0) {
                    const parentIndex = Math.floor((index - 1) / 2);
                    const parent = this.heap[parentIndex];
                    if (this.comparator(element, parent)) break;
                    this.heap[parentIndex] = element;
                    this.heap[index] = parent;
                    index = parentIndex;
                }
            }
            
            sinkDown(index) {
                const length = this.heap.length;
                const element = this.heap[index];
                
                while (true) {
                    let leftChildIndex = 2 * index + 1;
                    let rightChildIndex = 2 * index + 2;
                    let swap = null;
                    let leftChild, rightChild;
                    
                    if (leftChildIndex < length) {
                        leftChild = this.heap[leftChildIndex];
                        if (this.comparator(leftChild, element)) {
                            swap = leftChildIndex;
                        }
                    }
                    
                    if (rightChildIndex < length) {
                        rightChild = this.heap[rightChildIndex];
                        if (this.comparator(rightChild, (swap === null ? element : leftChild))) {
                            swap = rightChildIndex;
                        }
                    }
                    
                    if (swap === null) break;
                    this.heap[index] = this.heap[swap];
                    this.heap[swap] = element;
                    index = swap;
                }
            }
        }

        function init() {
            canvas = document.getElementById('mazeCanvas');
            ctx = canvas.getContext('2d');
            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;
            
            // Set up offscreen canvas for performance
            offscreenCanvas.width = CANVAS_WIDTH;
            offscreenCanvas.height = CANVAS_HEIGHT;
            
            // Set up event listeners
            document.getElementById('restartBtn').addEventListener('click', restartAnimation);
            document.getElementById('pauseBtn').addEventListener('click', togglePause);
            document.getElementById('stepBtn').addEventListener('click', stepAnimation);
            
            // Set up maze size slider
            const sizeSlider = document.getElementById('mazeSizeSlider');
            const sizeValue = document.getElementById('sizeValue');
            const performanceWarning = document.getElementById('performanceWarning');
            
            sizeSlider.addEventListener('input', function() {
                MAZE_SIZE = parseInt(this.value);
                sizeValue.textContent = MAZE_SIZE;
                
                // Show performance warning for large mazes
                performanceWarning.style.display = MAZE_SIZE > 50 ? 'block' : 'none';
            });
            
            sizeSlider.addEventListener('change', restartAnimation);
            
            // Algorithm selection buttons
            document.getElementById('primBtn').addEventListener('click', () => selectAlgorithm('prim', 'generation'));
            document.getElementById('huntkillBtn').addEventListener('click', () => selectAlgorithm('huntkill', 'generation'));
            document.getElementById('aldousbroderBtn').addEventListener('click', () => selectAlgorithm('aldousbroder', 'generation'));
            
            document.getElementById('astarBtn').addEventListener('click', () => selectAlgorithm('astar', 'solving'));
            document.getElementById('dijkstraBtn').addEventListener('click', () => selectAlgorithm('dijkstra', 'solving'));
            document.getElementById('bfsBtn').addEventListener('click', () => selectAlgorithm('bfs', 'solving'));
            
            // Start the animation
            restartAnimation();
        }

        function selectAlgorithm(algorithm, type) {
            if (type === 'generation') {
                generationAlgorithm = algorithm;
                
                // Update button states
                document.getElementById('primBtn').classList.toggle('toggled', algorithm === 'prim');
                document.getElementById('huntkillBtn').classList.toggle('toggled', algorithm === 'huntkill');
                document.getElementById('aldousbroderBtn').classList.toggle('toggled', algorithm === 'aldousbroder');
                
                // Update algorithm info
                const infoEl = document.getElementById('algorithmInfo');
                if (algorithm === 'prim') {
                    infoEl.textContent = "Prim's Algorithm: Creates a maze by randomly growing from a starting point, resulting in many short dead ends.";
                } else if (algorithm === 'huntkill') {
                    infoEl.textContent = "Hunt and Kill Algorithm: Creates a maze by 'walking' until stuck, then 'hunting' for a new starting point.";
                } else if (algorithm === 'aldousbroder') {
                    infoEl.textContent = "Aldous-Broder Algorithm: Creates a uniform spanning tree maze by random walk, resulting in a very random maze.";
                }
            } else {
                solvingAlgorithm = algorithm;
                
                // Update button states
                document.getElementById('astarBtn').classList.toggle('toggled', algorithm === 'astar');
                document.getElementById('dijkstraBtn').classList.toggle('toggled', algorithm === 'dijkstra');
                document.getElementById('bfsBtn').classList.toggle('toggled', algorithm === 'bfs');
            }
            
            restartAnimation();
        }

        function restartAnimation() {
            // Cancel any existing animation
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            // Reset state
            currentFrame = 0;
            particles = [];
            isPaused = false;
            precomputedGradientColors = {};
            pathLength = 0;
            
            // Update frame counts based on maze size
            GEN_FRAMES = GEN_DURATION * TARGET_FPS;
            SOLVE_FRAMES = SOLVE_DURATION * TARGET_FPS;
            TOTAL_FRAMES = GEN_FRAMES + SOLVE_FRAMES;
            
            // Generate new maze based on selected algorithm
            console.log("Generating maze using", generationAlgorithm, "...");
            let mazeResult;
            
            switch (generationAlgorithm) {
                case 'prim':
                    mazeResult = createMazePrim(MAZE_SIZE, MAZE_SIZE);
                    break;
                case 'huntkill':
                    mazeResult = createMazeHuntAndKill(MAZE_SIZE, MAZE_SIZE);
                    break;
                case 'aldousbroder':
                    mazeResult = createMazeAldousBroder(MAZE_SIZE, MAZE_SIZE);
                    break;
                default:
                    mazeResult = createMazePrim(MAZE_SIZE, MAZE_SIZE);
            }
            
            grid = mazeResult.grid;
            generationStates = mazeResult.generationStates;
            totalCells = mazeResult.cellsAdded;
            entrancePos = mazeResult.entrancePos;
            exitPos = mazeResult.exitPos;
            
            console.log("Solving maze using", solvingAlgorithm, "...");
            switch (solvingAlgorithm) {
                case 'astar':
                    solvingStates = solveMazeAStar(grid, entrancePos, exitPos);
                    break;
                case 'dijkstra':
                    solvingStates = solveMazeDijkstra(grid, entrancePos, exitPos);
                    break;
                case 'bfs':
                    solvingStates = solveMazeBFS(grid, entrancePos, exitPos);
                    break;
                default:
                    solvingStates = solveMazeAStar(grid, entrancePos, exitPos);
            }
            
            console.log("Creating animation frames...");
            frames = createAnimationFrames(generationStates, solvingStates);
            
            console.log("Starting animation...");
            animationId = requestAnimationFrame(drawAnimation);
        }

        function togglePause() {
            isPaused = !isPaused;
            document.getElementById('pauseBtn').textContent = isPaused ? 'Resume' : 'Pause';
            
            if (!isPaused && currentFrame < frames.length) {
                lastFrameTime = performance.now(); // Reset timing for FPS calculation
                animationId = requestAnimationFrame(drawAnimation);
            }
        }

        function stepAnimation() {
            if (isPaused && currentFrame < frames.length) {
                drawAnimation(performance.now());
            }
        }

        // Start everything when the page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
